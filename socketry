#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "typer>=0.9",
#     "paho-mqtt>=2.0",
#     "requests>=2.31",
#     "pycryptodome>=3.19",
# ]
# ///
"""Jackery power station control CLI.

Reverse-engineered from the Jackery iOS/Android app.
Controls devices via Jackery's MQTT broker (emqx.jackeryapp.com).
"""
from __future__ import annotations

import base64
import json
import os
import secrets
import ssl
import sys
import tempfile
import time
from dataclasses import dataclass
from pathlib import Path

import paho.mqtt.client as mqtt
import requests
import typer
from Crypto.Cipher import AES, PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad

app = typer.Typer(help="Control Jackery power stations.", invoke_without_command=True)


@app.callback()
def main(ctx: typer.Context) -> None:
    """Control Jackery power stations."""
    if ctx.invoked_subcommand is None:
        typer.echo(ctx.get_help())
        raise typer.Exit(0)

# ---------------------------------------------------------------------------
# Constants extracted from the decompiled APK (com.hbxn.jackery v1.0.7)
# ---------------------------------------------------------------------------

API_BASE = "https://iot.jackeryapp.com/v1"

MQTT_HOST = "emqx.jackeryapp.com"
MQTT_PORT = 8883

# Model code → human-readable name (from ha/c.java)
MODEL_NAMES: dict[int, str] = {
    1: "Explorer 3000 Pro",
    2: "Explorer 2000 Plus",
    4: "Explorer 300 Plus",
    5: "Explorer 1000 Plus",
    6: "Explorer 700 Plus",
    7: "Explorer 280 Plus",
    8: "Explorer 1000 Pro2",
    9: "Explorer 600 Plus",
    10: "Explorer 240",
    12: "Explorer 2000",
}


# ---------------------------------------------------------------------------
# Property definitions — single source of truth
# ---------------------------------------------------------------------------


@dataclass
class Setting:
    """A device property."""
    id: str                              # Raw key from the API (oac, rb, sltb)
    slug: str                            # CLI name (ac, battery, screen-timeout)
    name: str                            # Human-readable label
    group: str                           # Display group
    action_id: int | None = None         # MQTT action ID; None = read-only
    values: list[str] | None = None      # Enum values (index = int value); None = integer
    unit: str = ""                       # Suffix for display (%, W, Hz, C, h)
    scale: float = 1.0                   # Divide raw value by this for display
    decimals: int = 1                    # Decimal places when scale != 1
    write_id: str | None = None          # Override property key for MQTT writes

    @property
    def writable(self) -> bool:
        return self.action_id is not None

    @property
    def prop_key(self) -> str:
        """The property key to use in MQTT command bodies."""
        return self.write_id or self.id

    def format_value(self, raw: object) -> str:
        """Format a raw property value for human display."""
        if self.values is not None:
            try:
                idx = int(raw)  # type: ignore[arg-type]
                if 0 <= idx < len(self.values):
                    name = self.values[idx]
                    if set(self.values) == {"on", "off"}:
                        return name.upper()
                    return name
            except (ValueError, TypeError):
                pass
            return str(raw)
        if isinstance(raw, (int, float)):
            if self.unit == "h" and raw == 0:
                return "--"
            if self.scale != 1:
                return f"{raw / self.scale:.{self.decimals}f}{self.unit}"
            if self.unit:
                return f"{raw}{self.unit}"
        return str(raw)


PROPERTIES: list[Setting] = [
    # Battery & Power
    Setting("rb",   "battery",            "Battery",              "battery", unit="%"),
    Setting("bt",   "battery-temp",       "Battery temp",         "battery", unit="C", scale=10),
    Setting("bs",   "battery-state",      "Battery state",        "battery"),
    Setting("ip",   "input-power",        "Input power",          "battery", unit="W"),
    Setting("op",   "output-power",       "Output power",         "battery", unit="W"),
    Setting("it",   "input-time",         "Input time remaining", "battery", unit="h", scale=10),
    Setting("ot",   "output-time",        "Output time remaining","battery", unit="h", scale=10),
    # I/O State
    Setting("oac",  "ac",                 "AC output",            "io", action_id=4,  values=["off", "on"]),
    Setting("odc",  "dc",                 "DC output",            "io", action_id=1,  values=["off", "on"]),
    Setting("odcu", "usb",                "USB output",           "io", action_id=2,  values=["off", "on"]),
    Setting("odcc", "car",                "Car output",           "io", action_id=3,  values=["off", "on"]),
    Setting("iac",  "ac-in",              "AC input",             "io", action_id=5,  values=["off", "on"]),
    Setting("idc",  "dc-in",              "DC input",             "io", action_id=6,  values=["off", "on"]),
    Setting("lm",   "light",              "Light mode",           "io", action_id=7,  values=["off", "low", "high", "sos"]),
    Setting("wss",  "wireless",           "Wireless charging",    "io", values=["off", "on"]),
    # Settings
    Setting("cs",   "charge-speed",       "Charge speed",         "settings", action_id=10, values=["fast", "mute"]),
    Setting("ast",  "auto-shutdown",      "Auto shutdown",        "settings", action_id=9),
    Setting("pm",   "energy-saving",      "Energy saving",        "settings", action_id=12),
    Setting("lps",  "battery-protection", "Battery protection",   "settings", action_id=11, values=["full", "eco"]),
    Setting("sfc",  "sfc",                "Super fast charge",    "settings", action_id=13, values=["off", "on"]),
    Setting("ups",  "ups",                "UPS mode",             "settings", action_id=14, values=["off", "on"]),
    Setting("sltb", "screen-timeout",     "Screen timeout",       "settings", action_id=8, write_id="slt"),
    # AC / Power Detail
    Setting("acip", "ac-input-power",     "AC input power",       "power", unit="W"),
    Setting("cip",  "car-input-power",    "Car input power",      "power", unit="W"),
    Setting("acov", "ac-voltage",         "AC output voltage",    "power", unit="V", scale=10, decimals=0),
    Setting("acohz","ac-freq",            "AC output freq",       "power", unit="Hz"),
    Setting("acps", "ac-power",           "AC power",             "power", unit="W"),
    Setting("acpss","ac-power-2",         "AC power (secondary)", "power", unit="W"),
    Setting("acpsp","ac-socket-power",    "AC socket power",      "power", unit="W"),
    # Other / Alarms
    Setting("ec",   "error-code",         "Error code",           "other"),
    Setting("ta",   "temp-alarm",         "Temp alarm",           "other"),
    Setting("pal",  "power-alarm",        "Power alarm",          "other"),
    Setting("pmb",  "power-mode-battery", "Power mode battery",   "other"),
    Setting("tt",   "total-temp",         "Total temp",           "other"),
    Setting("ss",   "system-status",      "System status",        "other"),
    Setting("pc",   "power-capacity",     "Power capacity",       "other"),
]

_by_slug: dict[str, Setting] = {s.slug: s for s in PROPERTIES}
_by_id: dict[str, Setting] = {s.id: s for s in PROPERTIES}

GROUP_TITLES = {
    "battery": "Battery & Power",
    "io": "I/O State",
    "settings": "Settings",
    "power": "AC / Power Detail",
    "other": "Other",
}


def _print_json(obj: object) -> None:
    """Print JSON — syntax-highlighted when stdout is a TTY, compact otherwise."""
    if sys.stdout.isatty():
        from rich.console import Console
        from rich.syntax import Syntax
        Console().print(Syntax(json.dumps(obj, indent=2), "json"))
    else:
        typer.echo(json.dumps(obj))


def _resolve(name: str) -> Setting | None:
    """Look up a Setting by slug or raw property key."""
    return _by_slug.get(name) or _by_id.get(name)


RSA_PUBLIC_KEY_B64 = (
    "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCVmzgJy/4XolxPnkfu32YtJqYG"
    "FLYqf9/rnVgURJED+8J9J3Pccd6+9L97/+7COZE5OkejsgOkqeLNC9C3r5mhpE4z"
    "k/HStss7Q8/5DqkGD1annQ+eoICo3oi0dITZ0Qll56Dowb8lXi6WHViVDdih/oeU"
    "wVJY89uJNtTWrz7t7QIDAQAB"
)

# Self-signed CA cert for emqx.jackeryapp.com (from APK res/raw/ca.crt)
CA_CERT_PEM = """\
-----BEGIN CERTIFICATE-----
MIIDtTCCAp2gAwIBAgIJAPvYSRLMmPACMA0GCSqGSIb3DQEBCwUAMHAxCzAJBgNV
BAYTAkNOMRIwEAYDVQQIDAlHdWFuZ2RvbmcxETAPBgNVBAcMCFNoZW56aGVuMRQw
EgYDVQQKDAtqYWNrZXJ5LmNvbTELMAkGA1UECwwCY2ExFzAVBgNVBAMMDmNhLmph
Y2tlcnkuY29tMCAXDTIyMTIyMzEwMTc0N1oYDzIwNzcwOTI1MTAxNzQ3WjBwMQsw
CQYDVQQGEwJDTjESMBAGA1UECAwJR3Vhbmdkb25nMREwDwYDVQQHDAhTaGVuemhl
bjEUMBIGA1UECgwLamFja2VyeS5jb20xCzAJBgNVBAsMAmNhMRcwFQYDVQQDDA5j
YS5qYWNrZXJ5LmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOrf
QltVp+PDphQ20tfQbCh/YlqIAK8VkIcYXq7DlVsX1HGl5x+6UkEahzLRtZFaWRkH
HiHSvol8I+cvq6BHte0VsjKAzl7Mae7P/UyQXwpgNa+hliZHoEqflghzYvxjlZeP
eOGGcHxg1p2M8+PeNWkX5VkVTSYi/abDz86+D5y1gq7S8n+tYk1WhKFHvIrfX3nN
4QXfDO7vAQMd1uc6YdDqRanWjxIgOSDk9B+Mblz0TxCR+hnuDDQpAE4ONjByjArS
MC/QS8BIq/TL6nixzA8y0vOHySmuOLfuhFpNoO2mujhBGN/Dmq/pZwmsKSK91PxE
dn3YO8N8q7flHd/Qw4UCAwEAAaNQME4wHQYDVR0OBBYEFL/rQk0x4WclVgw3WLsl
YH3k0dvgMB8GA1UdIwQYMBaAFL/rQk0x4WclVgw3WLslYH3k0dvgMAwGA1UdEwQF
MAMBAf8wDQYJKoZIhvcNAQELBQADggEBALZM+xA4bUnO/7/0giZ3xUPEKzwFDp4G
5UPI/5grLYxp38t2M84tlJ94W/HKH+f1CYbJ6m28dSZfWtnRzQ3Tgq0whrsmYiK9
1Txcl3HPBiL7yAn3yE8DjHV+S2eSnN0o26/rcXCe+9bghSqqGaVDOJyk+Fm4l17e
Hzx99PvPGkpGUglun3UEp/Vp5ZUl9uDYT813HJ9jK80i1MDlzBJWmg7gzh27/Qls
UJLtYvgsxiBKAnK8YkAyu51Jm8uLz1BZ1RANf22vv0QUTW+SGdgc5Q1h610G9N1i
4BaijfWnto9ka32QKgZA0gHXsT3wiwdbEow0lp7y40aiXq4kazDT7ws=
-----END CERTIFICATE-----
"""

CRED_DIR = Path.home() / ".config" / "socketry"
CRED_FILE = CRED_DIR / "credentials.json"

APP_HEADERS = {
    "platform": "2",
    "app_version": "1.2.0",
    "Content-Type": "application/x-www-form-urlencoded",
}


# ---------------------------------------------------------------------------
# Crypto helpers
# ---------------------------------------------------------------------------


def _aes_ecb_encrypt(plaintext: bytes, key: bytes) -> bytes:
    """AES/ECB/PKCS5Padding encryption (used for HTTP login body)."""
    cipher = AES.new(key, AES.MODE_ECB)
    return cipher.encrypt(pad(plaintext, AES.block_size))


def _rsa_encrypt(plaintext: bytes, pub_key_b64: str) -> bytes:
    """RSA/ECB/PKCS1Padding encryption (used for encrypting AES key)."""
    der = base64.b64decode(pub_key_b64)
    key = RSA.import_key(der)
    cipher = PKCS1_v1_5.new(key)
    # For 1024-bit RSA, max plaintext is 117 bytes; our AES key is 24 bytes.
    return cipher.encrypt(plaintext)


def _aes_cbc_encrypt(plaintext: bytes, key: bytes, iv: bytes) -> bytes:
    """AES/CBC/PKCS5Padding encryption (used for MQTT password derivation)."""
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return cipher.encrypt(pad(plaintext, AES.block_size))


def _derive_mqtt_password(username: str, mqtt_password_b64: str) -> str:
    """Derive the MQTT connection password from the stored mqttPassWord.

    The app does: AES/CBC/PKCS5Padding(username, key=b64decode(mqttPassWord), iv=key[:16])
    then base64-encodes the result and sends it as the MQTT password string.
    """
    key = base64.b64decode(mqtt_password_b64)
    iv = key[:16]
    encrypted = _aes_cbc_encrypt(username.encode("utf-8"), key, iv)
    return base64.b64encode(encrypted).decode("ascii")


def _get_mac_id() -> str:
    """Generate a stable MAC-like identifier for this machine."""
    import uuid

    node = uuid.getnode()
    mac = ":".join(f"{(node >> (8 * i)) & 0xFF:02x}" for i in range(5, -1, -1))
    return mac


# ---------------------------------------------------------------------------
# HTTP login
# ---------------------------------------------------------------------------


def _fetch_all_devices(token: str) -> list[dict]:
    """Fetch all devices (owned + shared) using the given auth token.

    Returns a normalized list of dicts with keys: devSn, devName, devId,
    modelCode, shared.
    """
    auth_headers = {**APP_HEADERS, "token": token}
    all_devices: list[dict] = []

    # Owned devices
    dev_resp = requests.get(
        f"{API_BASE}/device/bind/list", headers=auth_headers, timeout=15
    )
    dev_resp.raise_for_status()
    for d in dev_resp.json().get("data") or []:
        all_devices.append(
            {
                "devSn": d["devSn"],
                "devName": d.get("devNickname") or d.get("devName") or d["devSn"],
                "devId": d.get("devId", ""),
                "modelCode": d.get("modelCode", 0),
                "shared": False,
            }
        )

    # Shared devices (device/bind/shared → receive → share/list for each)
    shared_resp = requests.get(
        f"{API_BASE}/device/bind/shared", headers=auth_headers, timeout=15
    )
    shared_resp.raise_for_status()
    shared_data = shared_resp.json().get("data") or {}
    for share in shared_data.get("receive", []):
        mgr_resp = requests.post(
            f"{API_BASE}/device/bind/share/list",
            data={
                "bindUserId": str(share["bindUserId"]),
                "level": str(share["level"]),
            },
            headers=auth_headers,
            timeout=15,
        )
        mgr_resp.raise_for_status()
        for d in mgr_resp.json().get("data", []):
            all_devices.append(
                {
                    "devSn": d["devSn"],
                    "devName": d.get("devNickname") or d.get("devName") or d["devSn"],
                    "devId": d.get("devId", ""),
                    "modelCode": d.get("modelCode", 0),
                    "shared": True,
                    "sharedBy": share.get("userName", ""),
                }
            )

    return all_devices


def _http_login(email: str, password: str) -> dict:
    """Perform the encrypted HTTP login and return credentials."""
    mac_id = _get_mac_id()
    login_bean = json.dumps(
        {
            "account": email,
            "password": password,
            "loginType": 2,
            "registerAppId": "com.hbxn.jackery",
            "macId": mac_id,
        },
        separators=(",", ":"),
    )

    # Generate random AES key: 16 bytes → base64 → 24-char string.
    # The app uses this base64 STRING's bytes (24 bytes, AES-192) as the actual
    # AES key material for encrypting the body AND as the RSA plaintext.
    aes_key_str = base64.b64encode(secrets.token_bytes(16)).decode("ascii")
    aes_key_bytes = aes_key_str.encode("utf-8")  # 24 bytes

    # Encrypt login body with AES/ECB using the 24-byte key
    encrypted_body = _aes_ecb_encrypt(login_bean.encode("utf-8"), aes_key_bytes)
    aes_encrypt_data = base64.b64encode(encrypted_body).decode("ascii")

    # RSA-encrypt the same 24-byte key string
    encrypted_key = _rsa_encrypt(aes_key_bytes, RSA_PUBLIC_KEY_B64)
    rsa_for_aes_key = base64.b64encode(encrypted_key).decode("ascii")

    resp = requests.post(
        f"{API_BASE}/auth/login",
        params={"aesEncryptData": aes_encrypt_data, "rsaForAesKey": rsa_for_aes_key},
        headers=APP_HEADERS,
        timeout=15,
    )
    resp.raise_for_status()
    body = resp.json()
    if body.get("code") != 0:
        typer.echo(f"Login failed: {body.get('msg', 'unknown error')}", err=True)
        raise typer.Exit(1)

    data = body["data"]
    token = body["token"]

    all_devices = _fetch_all_devices(token)
    if not all_devices:
        typer.echo("No owned or shared devices found.", err=True)
        raise typer.Exit(1)

    device = all_devices[0]

    creds = {
        "userId": data["userId"],
        "mqttPassWord": data["mqttPassWord"],
        "token": token,
        "deviceSn": device["devSn"],
        "deviceId": device["devId"],
        "deviceName": device["devName"],
        "email": email,
        "macId": mac_id,
        "devices": all_devices,
    }
    return creds


def _fetch_device_properties(token: str, device_id: str) -> dict:
    """Fetch full property map for a device via HTTP API."""
    auth_headers = {**APP_HEADERS, "token": token}
    resp = requests.get(
        f"{API_BASE}/device/property",
        params={"deviceId": device_id},
        headers=auth_headers,
        timeout=15,
    )
    resp.raise_for_status()
    body = resp.json()
    if body.get("code") != 0:
        typer.echo(f"Property fetch failed: {body.get('msg', 'unknown error')}", err=True)
        raise typer.Exit(1)
    return body.get("data") or {}


def _save_creds(creds: dict) -> None:
    CRED_DIR.mkdir(parents=True, exist_ok=True)
    CRED_FILE.write_text(json.dumps(creds, indent=2))
    CRED_FILE.chmod(0o600)


def _load_creds() -> dict | None:
    if CRED_FILE.exists():
        return json.loads(CRED_FILE.read_text())
    return None


def _ensure_creds() -> dict:
    creds = _load_creds()
    if creds:
        return creds
    typer.echo("No saved credentials. Run `socketry login` first.", err=True)
    raise typer.Exit(1)


# ---------------------------------------------------------------------------
# MQTT
# ---------------------------------------------------------------------------


def _make_mqtt_client(creds: dict) -> tuple[mqtt.Client, str]:
    """Create a configured MQTT client. Returns (client, ca_temp_path)."""
    user_id = creds["userId"]
    mac_id = creds.get("macId", _get_mac_id())
    mqtt_pw_b64 = creds["mqttPassWord"]

    client_id = f"{user_id}@APP"
    username = f"{user_id}@{mac_id}"
    password = _derive_mqtt_password(username, mqtt_pw_b64)

    ca_fd, ca_path = tempfile.mkstemp(suffix=".pem")
    os.write(ca_fd, CA_CERT_PEM.encode())
    os.close(ca_fd)

    client = mqtt.Client(
        callback_api_version=mqtt.CallbackAPIVersion.VERSION2,
        client_id=client_id,
        protocol=mqtt.MQTTv311,
    )
    client.username_pw_set(username, password)

    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.load_verify_locations(ca_path)
    client.tls_set_context(ctx)

    return client, ca_path


def _connect_and_wait(client: mqtt.Client, timeout: float = 5) -> None:
    """Connect to the MQTT broker and block until connected."""
    client.connect(MQTT_HOST, MQTT_PORT, keepalive=10)
    client.loop_start()
    deadline = time.time() + timeout
    while not client.is_connected() and time.time() < deadline:
        time.sleep(0.05)
    if not client.is_connected():
        typer.echo("Failed to connect to MQTT broker.", err=True)
        raise typer.Exit(1)


def _build_command_payload(device_sn: str, action_id: int, body: dict | str) -> str:
    """Build the JSON command payload for MQTT publish."""
    ts = int(time.time() * 1000)
    return json.dumps(
        {
            "deviceSn": device_sn,
            "id": ts,
            "version": 0,
            "messageType": "DevicePropertyChange",
            "actionId": action_id,
            "timestamp": ts,
            "body": body,
        },
        separators=(",", ":"),
    )


def _publish_command(creds: dict, action_id: int, body: dict | str) -> None:
    """Connect to Jackery MQTT broker and publish a device command."""
    user_id = creds["userId"]
    device_sn = creds["deviceSn"]
    topic = f"hb/app/{user_id}/command"
    payload = _build_command_payload(device_sn, action_id, body)

    client, ca_path = _make_mqtt_client(creds)
    try:
        _connect_and_wait(client)
        info = client.publish(topic, payload, qos=1)
        info.wait_for_publish(timeout=5)
        typer.echo(f"Command sent to {creds.get('deviceName', device_sn)}.")
        client.disconnect()
        client.loop_stop()
    finally:
        os.unlink(ca_path)


def _publish_and_wait(
    creds: dict, action_id: int, body: dict | str, timeout: float = 10,
    verbose: bool = False,
) -> dict | None:
    """Publish a command and wait for a DevicePropertyChange response.

    Subscribes to hb/app/{userId}/device, sends the command, and returns
    the first matching response body (or None on timeout).
    """
    user_id = creds["userId"]
    device_sn = creds["deviceSn"]
    cmd_topic = f"hb/app/{user_id}/command"
    dev_topic = f"hb/app/{user_id}/device"
    payload = _build_command_payload(device_sn, action_id, body)

    if verbose:
        typer.echo(f"  subscribe: {dev_topic}")
        typer.echo(f"  publish:   {cmd_topic}")
        typer.echo(f"  payload:   {payload}")

    result: dict | None = None
    done = False

    def on_connect(client: mqtt.Client, _ud: object, _flags: object, rc: int, _props: object = None) -> None:
        if verbose:
            typer.echo(f"  connected (rc={rc})")
        if rc == 0:
            client.subscribe(dev_topic, qos=1)

    def on_message(client: mqtt.Client, _ud: object, msg: mqtt.MQTTMessage) -> None:
        nonlocal result, done
        if verbose:
            typer.echo(f"  recv [{msg.topic}]: {msg.payload.decode('utf-8', errors='replace')}")
        try:
            data = json.loads(msg.payload)
        except json.JSONDecodeError:
            return
        if data.get("deviceSn") != device_sn:
            return
        msg_type = data.get("messageType", "")
        if msg_type == "DevicePropertyChange" and isinstance(data.get("body"), dict):
            resp_body = data["body"]
            # Skip broker acks that only contain messageId — wait for a real
            # device response which will have property keys like "rb", "oac", etc.
            if list(resp_body.keys()) == ["messageId"]:
                return
            result = data
            done = True

    client, ca_path = _make_mqtt_client(creds)
    client.on_connect = on_connect
    client.on_message = on_message
    try:
        _connect_and_wait(client)
        # Small delay to ensure subscription is active before publishing
        time.sleep(0.2)
        client.publish(cmd_topic, payload, qos=1)
        deadline = time.time() + timeout
        while not done and time.time() < deadline:
            time.sleep(0.1)
        client.disconnect()
        client.loop_stop()
    finally:
        os.unlink(ca_path)

    return result


# ---------------------------------------------------------------------------
# CLI commands
# ---------------------------------------------------------------------------


@app.command()
def login(
    email: str = typer.Option(..., prompt=True, help="Jackery account email"),
    password: str = typer.Option(
        ..., prompt=True, hide_input=True, help="Jackery account password"
    ),
) -> None:
    """Authenticate with Jackery and save credentials locally."""
    typer.echo(f"Logging in as {email}...")
    creds = _http_login(email, password)
    _save_creds(creds)
    n = len(creds.get("devices", []))
    typer.echo(
        f"Logged in. {n} device(s) found. "
        f"Selected: {creds['deviceName']} (SN: {creds['deviceSn']})"
    )


@app.command()
def devices() -> None:
    """List all devices (owned and shared). Refreshes from API."""
    creds = _ensure_creds()
    typer.echo("Fetching devices...")
    all_devices = _fetch_all_devices(creds["token"])
    if not all_devices:
        typer.echo("No devices found.", err=True)
        raise typer.Exit(1)

    # Update cached device list
    creds["devices"] = all_devices
    _save_creds(creds)

    selected_sn = creds.get("deviceSn", "")
    for i, dev in enumerate(all_devices):
        marker = "*" if dev["devSn"] == selected_sn else " "
        model = MODEL_NAMES.get(dev.get("modelCode", 0), "Unknown model")
        shared = f" (shared by {dev['sharedBy']})" if dev.get("shared") else ""
        typer.echo(f"  {marker} [{i}] {dev['devName']} — {model}{shared}")
        typer.echo(f"        SN: {dev['devSn']}")

    typer.echo("\n  * = selected.  Use `select <index>` to change.")


@app.command()
def select(index: int) -> None:
    """Select the active device by index (see `devices` for the list)."""
    creds = _ensure_creds()
    devs = creds.get("devices", [])
    if not devs:
        typer.echo("No cached device list. Run `devices` first.", err=True)
        raise typer.Exit(1)
    if index < 0 or index >= len(devs):
        typer.echo(f"Invalid index. Must be 0..{len(devs) - 1}.", err=True)
        raise typer.Exit(1)

    dev = devs[index]
    creds["deviceSn"] = dev["devSn"]
    creds["deviceId"] = dev["devId"]
    creds["deviceName"] = dev["devName"]
    _save_creds(creds)
    model = MODEL_NAMES.get(dev.get("modelCode", 0), "Unknown model")
    typer.echo(f"Selected: {dev['devName']} — {model} (SN: {dev['devSn']})")


@app.command("get", context_settings={"help_option_names": ["-h", "--help"]})
def get_property(
    ctx: typer.Context,
    name: str | None = typer.Argument(None, help="Property name or raw key"),
    as_json: bool = typer.Option(False, "--json", "-j", help="Output as JSON"),
) -> None:
    """Query device properties.

    \b
    Without arguments, shows all properties grouped.
    With a property name, shows just that value.
    Accepts CLI names (battery, ac) and raw keys (rb, oac).

    \b
    Battery & Power:
      battery, battery-temp, battery-state, input-power,
      output-power, input-time, output-time

    \b
    I/O State:
      ac, dc, usb, car, ac-in, dc-in, light, wireless

    \b
    Settings:
      charge-speed, auto-shutdown, energy-saving,
      battery-protection, sfc, ups, screen-timeout

    \b
    AC / Power Detail:
      ac-input-power, car-input-power, ac-voltage, ac-freq,
      ac-power, ac-power-2, ac-socket-power
    """
    creds = _ensure_creds()
    device_id = creds.get("deviceId", "")
    if not device_id:
        typer.echo("No deviceId in credentials. Run `login` or `devices` + `select` again.", err=True)
        raise typer.Exit(1)

    data = _fetch_device_properties(creds["token"], device_id)
    if not data:
        typer.echo("No properties returned.", err=True)
        raise typer.Exit(1)

    props = data.get("properties") or data

    # Single property query
    if name is not None:
        s = _resolve(name)
        if s is None:
            typer.echo(f"Unknown property '{name}'.", err=True)
            raise typer.Exit(1)
        if s.id not in props:
            typer.echo(f"Property '{name}' ({s.id}) not reported by device.", err=True)
            raise typer.Exit(1)
        raw = props[s.id]
        if as_json:
            _print_json({s.id: raw})
        else:
            typer.echo(f"{s.name}: {s.format_value(raw)}")
        return

    # All properties
    if as_json:
        _print_json(props)
        return

    dev_name = creds.get("deviceName", creds["deviceSn"])
    online = data.get("device", {}).get("onlineStatus", None)
    is_tty = sys.stdout.isatty()

    if is_tty:
        typer.echo(typer.style(dev_name, bold=True))
    else:
        typer.echo(dev_name)
    if online is not None:
        typer.echo(f"  Online: {'yes' if online == 1 else 'no'}")

    shown: set[str] = set()
    for group in ("battery", "io", "settings", "power"):
        group_settings = [s for s in PROPERTIES if s.group == group and s.id in props]
        if not group_settings:
            continue
        title = GROUP_TITLES[group]
        if is_tty:
            typer.echo(f"\n  {typer.style(title, bold=True)}")
        else:
            typer.echo(f"\n  {title}")
        for s in group_settings:
            raw = props[s.id]
            formatted = s.format_value(raw)
            if is_tty:
                typer.echo(f"    {typer.style(f'{s.name} ({s.slug})', fg='cyan')}: {formatted}")
            else:
                typer.echo(f"    {s.name} ({s.slug}): {formatted}")
            shown.add(s.id)

    # Any remaining unknown keys
    remaining = {k: v for k, v in props.items() if k not in shown}
    if remaining:
        if is_tty:
            typer.echo(f"\n  {typer.style('Other', bold=True)}")
        else:
            typer.echo("\n  Other")
        for k, v in remaining.items():
            s = _by_id.get(k)
            if s:
                label = f"{s.name} ({s.slug})"
                formatted = s.format_value(v)
            else:
                label = k
                formatted = str(v)
            if is_tty:
                typer.echo(f"    {typer.style(label, fg='cyan')}: {formatted}")
            else:
                typer.echo(f"    {label}: {formatted}")


@app.command("set", context_settings={"help_option_names": ["-h", "--help"]})
def set_setting(
    ctx: typer.Context,
    setting: str | None = typer.Argument(None, help="Setting name"),
    value: str | None = typer.Argument(None, help="Value to set"),
    wait: bool = typer.Option(False, "--wait", "-w", help="Wait for device confirmation"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Show MQTT traffic"),
) -> None:
    """Change a device setting via MQTT.

    \b
    Settings (named values):
      ac                    on | off
      dc                    on | off
      usb                   on | off
      car                   on | off
      ac-in                 on | off
      dc-in                 on | off
      light                 off | low | high | sos
      charge-speed          fast | mute
      battery-protection    full | eco
      sfc                   on | off
      ups                   on | off

    \b
    Settings (integer values):
      screen-timeout        <integer>
      auto-shutdown         <integer>
      energy-saving         <integer>
    """
    if setting is None:
        typer.echo(ctx.get_help())
        raise typer.Exit(0)

    s = _resolve(setting)
    if s is None or not s.writable:
        writable = [p for p in PROPERTIES if p.writable]
        names = ", ".join(p.slug for p in writable)
        if s and not s.writable:
            typer.echo(f"Property '{setting}' is read-only. Writable: {names}", err=True)
        else:
            typer.echo(f"Unknown setting '{setting}'. Available: {names}", err=True)
        raise typer.Exit(1)

    if value is None:
        if s.values:
            typer.echo(f"Setting '{s.slug}' expects a value: {' | '.join(s.values)}")
        else:
            typer.echo(f"Setting '{s.slug}' expects a value: <integer>")
        raise typer.Exit(0)

    if s.values:
        if value not in s.values:
            typer.echo(f"Invalid value '{value}' for {s.slug}. Expected: {' | '.join(s.values)}", err=True)
            raise typer.Exit(1)
        int_value = s.values.index(value)
    else:
        try:
            int_value = int(value)
        except ValueError:
            typer.echo(f"Invalid value '{value}' for {s.slug}. Expected an integer.", err=True)
            raise typer.Exit(1)

    creds = _ensure_creds()
    body = {s.prop_key: int_value}
    assert s.action_id is not None  # guaranteed by writable check above
    typer.echo(f"Setting {s.slug} to {value}...")

    if wait:
        result = _publish_and_wait(creds, s.action_id, body, verbose=verbose)
        if result:
            resp_props = result.get("body", {})
            for k, v in resp_props.items():
                rs = _by_id.get(k)
                if rs:
                    typer.echo(f"  {rs.name}: {rs.format_value(v)}")
                else:
                    typer.echo(f"  {k}: {v}")
        else:
            typer.echo("No response from device (timeout).", err=True)
    else:
        _publish_command(creds, s.action_id, body)


if __name__ == "__main__":
    app()
